# Домашнее задание к занятию "11.02 Микросервисы: принципы"

## Задача 1: API Gateway

<details>
Предложите решение для обеспечения реализации API Gateway. Составьте сравнительную таблицу возможностей различных программных решений. На основе таблицы сделайте выбор решения.

Решение должно соответствовать следующим требованиям:

Маршрутизация запросов к нужному сервису на основе конфигурации
Возможность проверки аутентификационной информации в запросах
Обеспечение терминации HTTPS
Обоснуйте свой выбор.
</details>

| Сервис | Маршрутизация | аутентификация | терминация HTTPS | внешняя СУБД | мониторинг | протоколы |
|--------|---------------|----------------|------------------|--------------|------------|-----------|
| [Nginx](http://nginx.org/) | Load balancer, Reverse proxy, Rate limiting | HTTP Basic Authentication  | TLS offload |  не требуется | external monitoring tools | HTTP/2 server push gRPC proxy |
| [HAProxy](http://www.haproxy.org/) | Load Balancing, Rate Limiting| да | HTTPS Termination |  не требуется | syslog | REST |
| [Kong](https://konghq.com/products/api-gateway-platform) | Rate Limiting, Load Balancing | Auth, HMAC, JWT Key Auth, limited OAuth 2.0, limited LDAP | да | не требуется(PostgreSQL) | File logging, HTTP logging, basic StatsD, TCP/UDP logging | REST, gRPC |
| [Tyk](https://tyk.io/) | Rate Limiting | OIDC, JWT, bearer Tokens, Basic Auth, Client Certificates | да |  Redis | да | REST, SOAP, GraphQL, gRPC|
| [KrakenD](https://www.krakend.io/) | Load Balancing, Rate limit, Sequential proxy | JWT, OAuth2 | TLS | не требуется | Metrics, Tracing, Alerting |  REST, GraphQL  |

Для перечисленных требований в качестве решения можно использовать любой продукт из таблицы. Nginx, HAProxy являются стабильными, надежными решениями, их функционала будет достаточно для обеспечения балансировки, проксирования соединений, установки как внешних так и внутренних лимитов скорости/времени подключения. Так же оба продукта могут обеспечить терминацию https трафика пользователей.  
Tyk и Kong, KrakenD являются полноценнми программынми API шлюзами, они способны предложить владельцу расширенный функционал авторизации, единый протокол API для всех клиентов, продвинутые функции администрирования и мониторинга состояния. Множество интересных функций к сожалению доступны только в Enterprise версии. 

Для обеспечения реализации API Gateway, при условии наличия бюджета, я предложил бы использовать Kong, т.к. он базируется на Nginx, что обеспечивет надежность и скорость работы базовых функций управления трафиком. Использование Lua позволяет реализовать сложную логику работы с пользователями/сервисами. 


## Задача 2: Брокер сообщений

<details>
Составьте таблицу возможностей различных брокеров сообщений. На основе таблицы сделайте обоснованный выбор решения.

Решение должно соответствовать следующим требованиям:

* Поддержка кластеризации для обеспечения надежности
* Хранение сообщений на диске в процессе доставки
* Высокая скорость работы
* Поддержка различных форматов сообщений
* Разделение прав доступа к различным потокам сообщений
* Проcтота эксплуатации
Обоснуйте свой выбор.
</details>

| Сервис | Кластеризация | Хранение данных | Протоколы | безопасность | Передача данных кленту|  
|--------|---------------|-----------------|-------------------|---------------|-----------------|
| Kafka  | да |  распределенный реплицируемый лог (храниться на диске)|Kafka Streams, REST API| шифрование, контроль доступа| pull |
|RabbitMQ| да | Временные очереди (храняться тольоко в памяти), долговечные очереди ( храняться на диске)|AMQP, MQTT, STOMP|шифрование, контроль доступа | push |
| HiveMQ | да |Временные очереди (храняться в памяти)|MQTT| шифрование, контроль доступа  | push |
|  NATS  | да |Временные очереди (храняться в памяти)|NATS Streaming|шифрование, контроль доступа  | push |
| ActiveMQ | да | Временные очереди (храняться только в памяти), долговечные очереди ( храняться на диске)| OpenWire,AMQP,STOMP,XMPP,MQTT, JMS API |контроль доступа|push|

В качестве брокера сообщений я бы остановил выбор на Apache Kafka. 
Kafka эффективно работает с диском, в своей работе он использует виртуальную память все остальные манипуляции осуществляет ядро. Использование в качестве хранилища дисковой подсистемы позволяет сохранять последовательность сообщений и дает возможность длительного хранения истории. Следующим плюсом является использование pull модели доставки сообщений. Клиенты сами управляют нагрузкой и фиксируют обработанные сообщения, это уменьшает накладные расходы как на клиент (при проблемах с производительностью можно ен опасаться ощибок  "отказ в обслуживание"), так и на сервер (нет необходимости отправлять каждый пакет).

## Задача 3: API Gateway 

<details>
Есть три сервиса:
minio

Хранит загруженные файлы в бакете images
S3 протокол
uploader

Принимает файл, если он картинка сжимает и загружает его в minio
POST /v1/upload
security

Регистрация пользователя POST /v1/user
Получение информации о пользователе GET /v1/user
Логин пользователя POST /v1/token
Проверка токена GET /v1/token/validation
Необходимо воспользоваться любым балансировщиком и сделать API Gateway:
POST /v1/register

Анонимный доступ.
Запрос направляется в сервис security POST /v1/user
POST /v1/token

Анонимный доступ.
Запрос направляется в сервис security POST /v1/token
GET /v1/user

Проверка токена. Токен ожидается в заголовке Authorization. Токен проверяется через вызов сервиса security GET /v1/token/validation/
Запрос направляется в сервис security GET /v1/user
POST /v1/upload

Проверка токена. Токен ожидается в заголовке Authorization. Токен проверяется через вызов сервиса security GET /v1/token/validation/
Запрос направляется в сервис uploader POST /v1/upload
GET /v1/user/{image}

Проверка токена. Токен ожидается в заголовке Authorization. Токен проверяется через вызов сервиса security GET /v1/token/validation/
Запрос направляется в сервис minio GET /images/{image}
</details>

